diff --git a/dep/gsoap/soapC.cpp b/dep/gsoap/soapC.cpp
index 2c675cc339..be583a0d44 100644
--- a/dep/gsoap/soapC.cpp
+++ b/dep/gsoap/soapC.cpp
@@ -482,7 +482,7 @@ SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, ch
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
 	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -519,7 +519,7 @@ SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
 	if (soap_out_int(soap, tag?tag:"int", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -676,7 +676,7 @@ SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct so
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
 	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -788,7 +788,7 @@ SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
 	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -907,7 +907,7 @@ SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
 	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -1028,7 +1028,7 @@ SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
 	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -1128,7 +1128,7 @@ SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
 	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -1236,7 +1236,7 @@ SOAP_FMAC3 struct ns1__executeCommand * SOAP_FMAC4 soap_in_ns1__executeCommand(s
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__executeCommand(struct soap *soap, const struct ns1__executeCommand *a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__executeCommand);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__executeCommand);
 	if (soap_out_ns1__executeCommand(soap, tag?tag:"ns1:executeCommand", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -1342,7 +1342,7 @@ SOAP_FMAC3 struct ns1__executeCommandResponse * SOAP_FMAC4 soap_in_ns1__executeC
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__executeCommandResponse(struct soap *soap, const struct ns1__executeCommandResponse *a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__executeCommandResponse);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__executeCommandResponse);
 	if (soap_out_ns1__executeCommandResponse(soap, tag?tag:"ns1:executeCommandResponse", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -1429,7 +1429,7 @@ SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reas
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
 	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -1486,7 +1486,7 @@ SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Deta
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
 	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -1543,7 +1543,7 @@ SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(s
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
 	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -1596,7 +1596,7 @@ SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
 	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -1623,7 +1623,7 @@ SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
 	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);
@@ -1665,7 +1665,7 @@ SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
 {
-	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
+	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
 	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
 		return soap->error;
 	return soap_putindependent(soap);


diff --git a/dep/gsoap/stdsoap2.cpp b/dep/gsoap/stdsoap2.cpp
index 36a8901dca..c5d6897e7e 100644
--- a/dep/gsoap/stdsoap2.cpp
+++ b/dep/gsoap/stdsoap2.cpp
@@ -532,7 +532,7 @@ extern int h_errno;
 #ifndef PALM_1
 static int
 fsend(struct soap *soap, const char *s, size_t n)
-{ register int nwritten, err;
+{ int nwritten, err;
   SOAP_SOCKET sk;
 #if defined(__cplusplus) && !defined(WITH_LEAN) && !defined(WITH_COMPAT)
   if (soap->os)
@@ -551,7 +551,7 @@ fsend(struct soap *soap, const char *s, size_t n)
     {
       if (soap->send_timeout)
       { for (;;)
-        { register int r;
+        { int r;
 #ifdef WITH_OPENSSL
           if (soap->ssl)
             r = tcp_select(soap, sk, SOAP_TCP_SELECT_ALL, soap->send_timeout);
@@ -624,7 +624,7 @@ fsend(struct soap *soap, const char *s, size_t n)
 #endif
       if (nwritten <= 0)
       {
-        register int r = 0;
+        int r = 0;
         err = soap_socket_errno(sk);
 #ifdef WITH_OPENSSL
         if (soap->ssl && (r = SSL_get_error(soap->ssl, nwritten)) != SSL_ERROR_NONE && r != SSL_ERROR_WANT_READ && r != SSL_ERROR_WANT_WRITE)
@@ -728,7 +728,7 @@ soap_send_raw(struct soap *soap, const char *s, size_t n)
   if (soap->mode & SOAP_IO_LENGTH)
     soap->count += n;
   else if (soap->mode & SOAP_IO)
-  { register size_t i = SOAP_BUFLEN - soap->bufidx;
+  { size_t i = SOAP_BUFLEN - soap->bufidx;
     while (n >= i)
     { memcpy(soap->buf + soap->bufidx, s, i);
       soap->bufidx = SOAP_BUFLEN;
@@ -753,12 +753,12 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_flush(struct soap *soap)
-{ register size_t n = soap->bufidx;
+{ size_t n = soap->bufidx;
   if (n)
   {
 #ifndef WITH_LEANER
     if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)
-    { register int r;
+    { int r;
       if (soap->fpreparesend && (r = soap->fpreparesend(soap, soap->buf, n)))
         return soap->error = r;
     }
@@ -800,7 +800,7 @@ int
 SOAP_FMAC2
 soap_flush_raw(struct soap *soap, const char *s, size_t n)
 { if ((soap->mode & SOAP_IO) == SOAP_IO_STORE)
-  { register char *t;
+  { char *t;
     if (!(t = (char*)soap_push_block(soap, NULL, n)))
       return soap->error = SOAP_EOM;
     memcpy(t, s, n);
@@ -867,8 +867,8 @@ soap_send3(struct soap *soap, const char *s1, const char *s2, const char *s3)
 #ifndef PALM_1
 static size_t
 frecv(struct soap *soap, char *s, size_t n)
-{ register int r;
-  register int retries = 100; /* max 100 retries with non-blocking sockets */
+{ int r;
+  int retries = 100; /* max 100 retries with non-blocking sockets */
   SOAP_SOCKET sk;
   soap->errnum = 0;
 #if defined(__cplusplus) && !defined(WITH_LEAN) && !defined(WITH_COMPAT)
@@ -885,7 +885,7 @@ frecv(struct soap *soap, char *s, size_t n)
   { for (;;)
     {
 #ifdef WITH_OPENSSL
-      register int err = 0;
+      int err = 0;
 #endif
 #ifdef WITH_OPENSSL
       if (soap->recv_timeout && !soap->ssl) /* SSL: sockets are nonblocking */
@@ -1039,9 +1039,9 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_recv_raw(struct soap *soap)
-{ register size_t ret;
+{ size_t ret;
 #if !defined(WITH_LEANER) || defined(WITH_ZLIB)
-  register int r;
+  int r;
 #endif
 #ifdef WITH_ZLIB
   if (soap->mode & SOAP_ENC_ZLIB)
@@ -1095,7 +1095,7 @@ zlib_again:
 #ifndef WITH_NOHTTP
   if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK) /* read HTTP chunked transfer */
   { for (;;)
-    { register soap_wchar c;
+    { soap_wchar c;
       char *t, tmp[17];
       if (soap->chunksize)
       { soap->buflen = ret = soap->frecv(soap, soap->buf, soap->chunksize > SOAP_BUFLEN ? SOAP_BUFLEN : soap->chunksize);
@@ -1318,7 +1318,7 @@ SOAP_FMAC1
 soap_wchar
 SOAP_FMAC2
 soap_getchar(struct soap *soap)
-{ register soap_wchar c;
+{ soap_wchar c;
   c = soap->ahead;
   if (c)
   { if (c != EOF)
@@ -1383,12 +1383,12 @@ SOAP_FMAC1
 long
 SOAP_FMAC2
 soap_code_bits(const struct soap_code_map *code_map, const char *str)
-{ register long bits = 0;
+{ long bits = 0;
   if (code_map)
   { while (str && *str)
     { const struct soap_code_map *p;
       for (p = code_map; p->string; p++)
-      { register size_t n = strlen(p->string);
+      { size_t n = strlen(p->string);
         if (!strncmp(p->string, str, n) && soap_blank((soap_wchar)str[n]))
         { bits |= p->code;
           str += n;
@@ -1411,11 +1411,11 @@ SOAP_FMAC1
 const char*
 SOAP_FMAC2
 soap_code_list(struct soap *soap, const struct soap_code_map *code_map, long code)
-{ register char *t = soap->tmpbuf;
+{ char *t = soap->tmpbuf;
   if (code_map)
   { while (code_map->string)
     { if (code_map->code & code)
-      { register const char *s = code_map->string;
+      { const char *s = code_map->string;
         if (t != soap->tmpbuf)
           *t++ = ' ';
         while (*s && t < soap->tmpbuf + sizeof(soap->tmpbuf) - 1)
@@ -1436,9 +1436,9 @@ soap_code_list(struct soap *soap, const struct soap_code_map *code_map, long cod
 static soap_wchar
 soap_char(struct soap *soap)
 { char tmp[8];
-  register int i;
-  register soap_wchar c;
-  register char *s = tmp;
+  int i;
+  soap_wchar c;
+  char *s = tmp;
   for (i = 0; i < 7; i++)
   { c = soap_get1(soap);
     if (c == ';' || (int)c == EOF)
@@ -1499,7 +1499,7 @@ SOAP_FMAC1
 soap_wchar
 SOAP_FMAC2
 soap_get(struct soap *soap)
-{ register soap_wchar c;
+{ soap_wchar c;
   c = soap->ahead;
   if (c)
   { if ((int)c != EOF)
@@ -1536,7 +1536,7 @@ soap_get(struct soap *soap)
         do c = soap_get1(soap);
         while (soap_blank(c));
         if (c == '!' || c == '?' || c == '%')
-        { register int k = 1;
+        { int k = 1;
           if (c == '!')
           { c = soap_get1(soap);
             if (c == '[')
@@ -1596,9 +1596,9 @@ soap_get(struct soap *soap)
 static soap_wchar
 soap_get_pi(struct soap *soap)
 { char buf[64];
-  register char *s = buf;
-  register int i = sizeof(buf);
-  register soap_wchar c = soap_getchar(soap);
+  char *s = buf;
+  int i = sizeof(buf);
+  soap_wchar c = soap_getchar(soap);
   /* This is a quick way to parse XML PI and we could use a callback instead to
    * enable applications to intercept processing instructions */
   while ((int)c != EOF && c != '?')
@@ -1664,7 +1664,7 @@ soap_tell(struct soap *soap)
 SOAP_FMAC1
 int
 SOAP_FMAC2
-soap_pututf8(struct soap *soap, register unsigned long c)
+soap_pututf8(struct soap *soap, unsigned long c)
 { char tmp[16];
   if (c < 0x80 && c > 0)
   { *tmp = (char)c;
@@ -1672,7 +1672,7 @@ soap_pututf8(struct soap *soap, register unsigned long c)
   }
 #ifndef WITH_LEAN
   if (c >= 0x80)
-  { register char *t = tmp;
+  { char *t = tmp;
     if (c < 0x0800)
       *t++ = (char)(0xC0 | ((c >> 6) & 0x1F));
     else
@@ -1710,7 +1710,7 @@ SOAP_FMAC1
 soap_wchar
 SOAP_FMAC2
 soap_getutf8(struct soap *soap)
-{ register soap_wchar c, c1, c2, c3, c4;
+{ soap_wchar c, c1, c2, c3, c4;
   c = soap->ahead;
   if (c)
     soap->ahead = 0;
@@ -1746,7 +1746,7 @@ int
 SOAP_FMAC2
 soap_puthex(struct soap *soap, const unsigned char *s, int n)
 { char d[2];
-  register int i;
+  int i;
 #ifdef WITH_DOM
   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
   { if (!(soap->dom->data = soap_s2hex(soap, s, NULL, n)))
@@ -1755,7 +1755,7 @@ soap_puthex(struct soap *soap, const unsigned char *s, int n)
   }
 #endif
   for (i = 0; i < n; i++)
-  { register int m = *s++;
+  { int m = *s++;
     d[0] = (char)((m >> 4) + (m > 159 ? '7' : '0'));
     m &= 0x0F;
     d[1] = (char)(m + (m > 9 ? '7' : '0'));
@@ -1782,16 +1782,16 @@ soap_gethex(struct soap *soap, int *n)
 #ifdef WITH_FAST
   soap->labidx = 0;
   for (;;)
-  { register char *s;
-    register size_t i, k;
+  { char *s;
+    size_t i, k;
     if (soap_append_lab(soap, NULL, 0))
       return NULL;
     s = soap->labbuf + soap->labidx;
     k = soap->lablen - soap->labidx;
     soap->labidx = soap->lablen;
     for (i = 0; i < k; i++)
-    { register char d1, d2;
-      register soap_wchar c;
+    { char d1, d2;
+      soap_wchar c;
       c = soap_get(soap);
       if (soap_isxdigit(c))
       { d1 = (char)c;
@@ -1820,15 +1820,15 @@ soap_gethex(struct soap *soap, int *n)
   if (soap_new_block(soap) == NULL)
     return NULL;
   for (;;)
-  { register int i;
-    register char *s = (char*)soap_push_block(soap, NULL, SOAP_BLKLEN);
+  { int i;
+    char *s = (char*)soap_push_block(soap, NULL, SOAP_BLKLEN);
     if (!s)
     { soap_end_block(soap, NULL);
       return NULL;
     }
     for (i = 0; i < SOAP_BLKLEN; i++)
-    { register char d1, d2;
-      register soap_wchar c = soap_get(soap);
+    { char d1, d2;
+      soap_wchar c = soap_get(soap);
       if (soap_isxdigit(c))
       { d1 = (char)c;
         c = soap_get(soap);
@@ -1861,8 +1861,8 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_putbase64(struct soap *soap, const unsigned char *s, int n)
-{ register int i;
-  register unsigned long m;
+{ int i;
+  unsigned long m;
   char d[4];
   if (!s)
     return SOAP_OK;
@@ -1915,8 +1915,8 @@ soap_getbase64(struct soap *soap, int *n, int malloc_flag)
 #ifdef WITH_FAST
   soap->labidx = 0;
   for (;;)
-  { register size_t i, k;
-    register char *s;
+  { size_t i, k;
+    char *s;
     if (soap_append_lab(soap, NULL, 2))
       return NULL;
     s = soap->labbuf + soap->labidx;
@@ -1926,10 +1926,10 @@ soap_getbase64(struct soap *soap, int *n, int malloc_flag)
       return NULL;
     if (k > 2)
     { for (i = 0; i < k - 2; i += 3)
-      { register unsigned long m = 0;
-        register int j = 0;
+      { unsigned long m = 0;
+        int j = 0;
         do
-        { register soap_wchar c = soap_get(soap);
+        { soap_wchar c = soap_get(soap);
 	  if (c < SOAP_AP)
 	    c &= 0x7FFFFFFF;
           if (c == '=' || c < 0)
@@ -1958,7 +1958,7 @@ soap_getbase64(struct soap *soap, int *n, int malloc_flag)
           }
           c -= '+';
           if (c >= 0 && c <= 79)
-          { register int b = soap_base64i[c];
+          { int b = soap_base64i[c];
             if (b >= 64)
             { soap->error = SOAP_TYPE;
               return NULL;
@@ -1981,17 +1981,17 @@ soap_getbase64(struct soap *soap, int *n, int malloc_flag)
   if (soap_new_block(soap) == NULL)
     return NULL;
   for (;;)
-  { register int i;
-    register char *s = (char*)soap_push_block(soap, NULL, 3 * SOAP_BLKLEN); /* must be multiple of 3 */
+  { int i;
+    char *s = (char*)soap_push_block(soap, NULL, 3 * SOAP_BLKLEN); /* must be multiple of 3 */
     if (!s)
     { soap_end_block(soap, NULL);
       return NULL;
     }
     for (i = 0; i < SOAP_BLKLEN; i++)
-    { register unsigned long m = 0;
-      register int j = 0;
+    { unsigned long m = 0;
+      int j = 0;
       do
-      { register soap_wchar c = soap_get(soap);
+      { soap_wchar c = soap_get(soap);
         if (c == '=' || c < 0)
         { unsigned char *p;
           i *= 3;
@@ -2194,12 +2194,12 @@ soap_update_pointers(struct soap *soap, char *start, char *end, char *p1, char *
 {
 #ifndef WITH_NOIDREF
   int i;
-  register struct soap_ilist *ip = NULL;
-  register struct soap_flist *fp = NULL;
+  struct soap_ilist *ip = NULL;
+  struct soap_flist *fp = NULL;
 #ifndef WITH_LEANER
-  register struct soap_xlist *xp = NULL;
+  struct soap_xlist *xp = NULL;
 #endif
-  register void *p, **q;
+  void *p, **q;
   for (i = 0; i < SOAP_IDHASH; i++)
   { for (ip = soap->iht[i]; ip; ip = ip->next)
     { if (ip->ptr && (char*)ip->ptr >= start && (char*)ip->ptr < end)
@@ -2249,11 +2249,11 @@ soap_update_pointers(struct soap *soap, char *start, char *end, char *p1, char *
 #ifndef WITH_NOIDREF
 #ifndef PALM_1
 static int
-soap_has_copies(struct soap *soap, register const char *start, register const char *end)
-{ register int i;
-  register struct soap_ilist *ip = NULL;
-  register struct soap_flist *fp = NULL;
-  register const char *p;
+soap_has_copies(struct soap *soap, const char *start, const char *end)
+{ int i;
+  struct soap_ilist *ip = NULL;
+  struct soap_flist *fp = NULL;
+  const char *p;
   for (i = 0; i < SOAP_IDHASH; i++)
   { for (ip = soap->iht[i]; ip; ip = ip->next)
     { for (p = (const char*)ip->copy; p; p = *(const char**)p)
@@ -2276,15 +2276,15 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_resolve(struct soap *soap)
-{ register int i;
-  register struct soap_ilist *ip = NULL;
-  register struct soap_flist *fp = NULL;
+{ int i;
+  struct soap_ilist *ip = NULL;
+  struct soap_flist *fp = NULL;
   short flag;
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving forwarded data\n"));
   for (i = 0; i < SOAP_IDHASH; i++)
   { for (ip = soap->iht[i]; ip; ip = ip->next)
     { if (ip->ptr)
-      { register void *p, **q, *r;
+      { void *p, **q, *r;
         q = (void**)ip->link;
         ip->link = NULL;
         r = ip->ptr;
@@ -2310,7 +2310,7 @@ soap_resolve(struct soap *soap)
     { for (ip = soap->iht[i]; ip; ip = ip->next)
       { if (ip->ptr && !soap_has_copies(soap, (const char*)ip->ptr, (const char*)ip->ptr + ip->size))
         { if (ip->copy)
-          { register void *p, **q = (void**)ip->copy;
+          { void *p, **q = (void**)ip->copy;
             DBGLOG(TEST, if (q) SOAP_MESSAGE(fdebug, "Traversing copy chain to resolve id='%s'\n", ip->id));
             ip->copy = NULL;
             do
@@ -2322,11 +2322,11 @@ soap_resolve(struct soap *soap)
             flag = 1;
           }
           for (fp = ip->flist; fp; fp = ip->flist)
-          { register unsigned int k = fp->level;
-            register void *p = ip->ptr;
+          { unsigned int k = fp->level;
+            void *p = ip->ptr;
             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving forwarded data type=%d location=%p level=%u,%u id='%s'\n", ip->type, p, ip->level, fp->level, ip->id));
             while (ip->level < k)
-            { register void **q = (void**)soap_malloc(soap, sizeof(void*));
+            { void **q = (void**)soap_malloc(soap, sizeof(void*));
               if (!q)
                 return soap->error;
               *q = p;
@@ -2473,8 +2473,8 @@ SOAP_FMAC1
 char*
 SOAP_FMAC2
 soap_save_block(struct soap *soap, struct soap_blist *b, char *p, int flag)
-{ register size_t n;
-  register char *q, *s;
+{ size_t n;
+  char *q, *s;
   if (!b)
     b = soap->blist;
   if (b->size)
@@ -2568,7 +2568,7 @@ SOAP_FMAC1
 char *
 SOAP_FMAC2
 soap_putoffsets(struct soap *soap, const int *offset, int dim)
-{ register int i;
+{ int i;
   sprintf(soap->arrayOffset, "[%d", offset[0]);
   for (i = 1; i < dim; i++)
     sprintf(soap->arrayOffset + strlen(soap->arrayOffset), ",%d", offset[i]);
@@ -2583,7 +2583,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_size(const int *size, int dim)
-{ register int i, n = size[0];
+{ int i, n = size[0];
   for (i = 1; i < dim; i++)
     n *= size[i];
   return n;
@@ -2596,7 +2596,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_getoffsets(const char *attr, const int *size, int *offset, int dim)
-{ register int i, j = 0;
+{ int i, j = 0;
   if (offset)
     for (i = 0; i < dim && attr && *attr; i++)
     { attr++;
@@ -2621,7 +2621,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_getsize(const char *attr1, const char *attr2, int *j)
-{ register int n, k;
+{ int n, k;
   char *s;
   *j = 0;
   if (!*attr1)
@@ -2660,7 +2660,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_getsizes(const char *attr, int *size, int dim)
-{ register int i, k, n;
+{ int i, k, n;
   if (!*attr)
     return -1;
   i = (int)strlen(attr);
@@ -2684,7 +2684,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_getposition(const char *attr, int *pos)
-{ register int i, n;
+{ int i, n;
   if (!*attr)
     return -1;
   n = 0;
@@ -2706,10 +2706,10 @@ SOAP_FMAC1
 struct soap_nlist *
 SOAP_FMAC2
 soap_push_namespace(struct soap *soap, const char *id, const char *ns)
-{ register struct soap_nlist *np;
-  register struct Namespace *p;
-  register short i = -1;
-  register size_t n, k;
+{ struct soap_nlist *np;
+  struct Namespace *p;
+  short i = -1;
+  size_t n, k;
   n = strlen(id);
   k = strlen(ns) + 1;
   p = soap->local_namespaces;
@@ -2763,7 +2763,7 @@ SOAP_FMAC1
 void
 SOAP_FMAC2
 soap_pop_namespace(struct soap *soap)
-{ register struct soap_nlist *np, *nq;
+{ struct soap_nlist *np, *nq;
   for (np = soap->nlist; np && np->level >= soap->level; np = nq)
   { nq = np->next;
     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Pop namespace binding (level=%u) '%s'\n", soap->level, np->id));
@@ -2779,7 +2779,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_match_namespace(struct soap *soap, const char *id1, const char *id2, size_t n1, size_t n2)
-{ register struct soap_nlist *np = soap->nlist;
+{ struct soap_nlist *np = soap->nlist;
   const char *s;
   while (np && (strncmp(np->id, id1, n1) || np->id[n1]))
     np = np->next;
@@ -2805,8 +2805,8 @@ SOAP_FMAC1
 const char*
 SOAP_FMAC2
 soap_current_namespace(struct soap *soap, const char *tag)
-{ register struct soap_nlist *np;
-  register const char *s;
+{ struct soap_nlist *np;
+  const char *s;
   if (!tag || !strncmp(tag, "xml", 3))
     return NULL;
   np = soap->nlist;
@@ -2837,8 +2837,8 @@ int
 SOAP_FMAC2
 soap_tag_cmp(const char *s, const char *t)
 { for (;;)
-  { register int c1 = *s;
-    register int c2 = *t;
+  { int c1 = *s;
+    int c2 = *t;
     if (!c1 || c1 == '"')
       break;
     if (c2 != '-')
@@ -2884,8 +2884,8 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_match_tag(struct soap *soap, const char *tag1, const char *tag2)
-{ register const char *s, *t;
-  register int err;
+{ const char *s, *t;
+  int err;
   if (!tag1 || !tag2 || !*tag2)
     return SOAP_OK;
   s = strchr(tag1, ':');
@@ -3597,7 +3597,7 @@ tcp_init(struct soap *soap)
 #ifndef PALM_1
 static const char*
 tcp_error(struct soap *soap)
-{ register const char *msg = NULL;
+{ const char *msg = NULL;
   switch (soap->errmode)
   { case 0:
       msg = soap_strerror(soap);
@@ -3975,7 +3975,7 @@ again:
       {
         SOAP_SOCKLEN_T k;
         for (;;)
-        { register int r;
+        { int r;
           r = tcp_select(soap, sk, SOAP_TCP_SELECT_SND, soap->connect_timeout);
           if (r > 0)
             break;
@@ -4141,7 +4141,7 @@ again:
     { if ((r = SSL_connect(soap->ssl)) <= 0)
       { int err = SSL_get_error(soap->ssl, r);
         if (err == SSL_ERROR_WANT_CONNECT || err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE)
-        { register int s;
+        { int s;
           if (err == SSL_ERROR_WANT_READ)
             s = tcp_select(soap, sk, SOAP_TCP_SELECT_RCV | SOAP_TCP_SELECT_ERR, -100000);
           else
@@ -4352,7 +4352,7 @@ again:
 #ifndef PALM_1
 static int
 tcp_select(struct soap *soap, SOAP_SOCKET sk, int flags, int timeout)
-{ register int r;
+{ int r;
   struct timeval tv;
   fd_set fd[3], *rfd, *sfd, *efd;
   soap->errnum = 0;
@@ -4765,7 +4765,7 @@ SOAP_FMAC2
 soap_poll(struct soap *soap)
 {
 #ifndef WITH_LEAN
-  register int r;
+  int r;
   if (soap_valid_socket(soap->socket))
   { r = tcp_select(soap, soap->socket, SOAP_TCP_SELECT_ALL, 0);
     if (r > 0 && (r & SOAP_TCP_SELECT_ERR))
@@ -4817,7 +4817,7 @@ SOAP_SOCKET
 SOAP_FMAC2
 soap_accept(struct soap *soap)
 { int n = (int)sizeof(soap->peer);
-  register int err;
+  int err;
 #ifndef WITH_LEAN
 #ifndef WIN32
   int len = SOAP_BUFLEN;
@@ -4843,7 +4843,7 @@ soap_accept(struct soap *soap)
   for (;;)
   { if (soap->accept_timeout || soap->send_timeout || soap->recv_timeout)
     { for (;;)
-      { register int r;
+      { int r;
         r = tcp_select(soap, soap->master, SOAP_TCP_SELECT_ALL, soap->accept_timeout ? soap->accept_timeout : 60);
         if (r > 0)
           break;
@@ -4954,7 +4954,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_closesock(struct soap *soap)
-{ register int status = soap->error;
+{ int status = soap->error;
 #ifndef WITH_LEANER
   if (status) /* close on error: attachment state is not to be trusted */
   { soap->mime.first = NULL;
@@ -5039,7 +5039,7 @@ soap_done(struct soap *soap)
   soap_free_cookies(soap);
 #endif
   while (soap->plugins)
-  { register struct soap_plugin *p = soap->plugins->next;
+  { struct soap_plugin *p = soap->plugins->next;
     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Removing plugin '%s'\n", soap->plugins->id));
     if (soap->plugins->fcopy || soap->state == SOAP_INIT)
       soap->plugins->fdelete(soap, soap->plugins);
@@ -5504,10 +5504,10 @@ SOAP_FMAC1
 const char*
 SOAP_FMAC2
 soap_get_header_attribute(struct soap *soap, const char *line, const char *key)
-{ register const char *s = line;
+{ const char *s = line;
   if (s)
   { while (*s)
-    { register short flag;
+    { short flag;
       s = soap_decode_key(soap->tmpbuf, sizeof(soap->tmpbuf), s);
       flag = soap_tag_cmp(soap->tmpbuf, key);
       s = soap_decode_val(soap->tmpbuf, sizeof(soap->tmpbuf), s);
@@ -5587,7 +5587,7 @@ soap_decode(char *buf, size_t len, const char *val, const char *sep)
 #ifndef PALM_1
 static const char*
 http_error(struct soap *soap, int status)
-{ register const char *msg = SOAP_STR_EOS;
+{ const char *msg = SOAP_STR_EOS;
   (void)soap;
 #ifndef WITH_LEAN
   msg = soap_code_str(h_http_error_codes, status);
@@ -5638,8 +5638,8 @@ http_200(struct soap *soap)
 #ifndef PALM_1
 static int
 http_post(struct soap *soap, const char *endpoint, const char *host, int port, const char *path, const char *action, size_t count)
-{ register const char *s;
-  register int err;
+{ const char *s;
+  int err;
   switch (soap->status)
   { case SOAP_GET: 
       s = "GET";
@@ -5756,7 +5756,7 @@ http_post(struct soap *soap, const char *endpoint, const char *host, int port, c
 #ifndef PALM_1
 static int
 http_send_header(struct soap *soap, const char *s)
-{ register const char *t;
+{ const char *t;
   do
   { t = strchr(s, '\n'); /* disallow \n in HTTP headers */
     if (!t)
@@ -5791,7 +5791,7 @@ http_post_header(struct soap *soap, const char *key, const char *val)
 #ifndef PALM_1
 static int
 http_response(struct soap *soap, int status, size_t count)
-{ register int err;
+{ int err;
 #ifdef WMW_RPM_IO
   if (soap->rpmreqid)
     httpOutputEnable(soap->rpmreqid);
@@ -5872,7 +5872,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_response(struct soap *soap, int status)
-{ register size_t count;
+{ size_t count;
   if (!(soap->omode & (SOAP_ENC_XML | SOAP_IO_STORE /* this tests for chunking too */))
    && (status == SOAP_HTML || status == SOAP_FILE))
     soap->omode = (soap->omode & ~SOAP_IO) | SOAP_IO_STORE;
@@ -5882,7 +5882,7 @@ soap_response(struct soap *soap, int status)
     return soap->error;
 #ifndef WITH_NOHTTP
   if ((soap->mode & SOAP_IO) != SOAP_IO_STORE && !(soap->mode & SOAP_ENC_XML))
-  { register int n = soap->mode;
+  { int n = soap->mode;
     soap->mode &= ~(SOAP_IO | SOAP_ENC_ZLIB);
     if ((n & SOAP_IO) != SOAP_IO_FLUSH)
       soap->mode |= SOAP_IO_BUFFER;
@@ -5913,8 +5913,8 @@ SOAP_FMAC1
 size_t
 SOAP_FMAC2
 soap_encode_cookie(const char *s, char *t, size_t len)
-{ register int c;
-  register size_t n = len;
+{ int c;
+  size_t n = len;
   while ((c = *s++) && --n > 0)
   { if (c > ' ' && c < 128 && !strchr("()<>@,;:\\\"/[]?={}#!$&'*+", c))
       *t++ = c;
@@ -6608,8 +6608,8 @@ soap_free_cookies(struct soap *soap)
 SOAP_FMAC1
 size_t
 SOAP_FMAC2
-soap_hash(register const char *s)
-{ register size_t h = 0;
+soap_hash(const char *s)
+{ size_t h = 0;
   while (*s)
     h = 65599*h + *s++;
   return h % SOAP_IDHASH;
@@ -6622,7 +6622,7 @@ soap_hash(register const char *s)
 #ifndef PALM_1
 static void
 soap_init_pht(struct soap *soap)
-{ register int i;
+{ int i;
   soap->pblk = NULL;
   soap->pidx = 0;
   for (i = 0; i < (int)SOAP_PTRHASH; i++)
@@ -6670,8 +6670,8 @@ soap_del(struct soap *soap)
 #ifndef PALM_1
 static void
 soap_free_pht(struct soap *soap)
-{ register struct soap_pblk *pb, *next;
-  register int i;
+{ struct soap_pblk *pb, *next;
+  int i;
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free pointer hashtable\n"));
   for (pb = soap->pblk; pb; pb = next)
   { next = pb->next;
@@ -6692,7 +6692,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_embed(struct soap *soap, const void *p, const struct soap_array *a, int n, const char *tag, int type)
-{ register int i;
+{ int i;
   struct soap_plist *pp;
   if (soap->version == 2)
     soap->encoding = 1;
@@ -6719,7 +6719,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_pointer_lookup(struct soap *soap, const void *p, int type, struct soap_plist **ppp)
-{ register struct soap_plist *pp;
+{ struct soap_plist *pp;
   *ppp = NULL;
   if (p)
   { for (pp = soap->pht[soap_hash_ptr(p)]; pp; pp = pp->next)
@@ -6743,10 +6743,10 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_pointer_enter(struct soap *soap, const void *p, const struct soap_array *a, int n, int type, struct soap_plist **ppp)
-{ register size_t h;
-  register struct soap_plist *pp;
+{ size_t h;
+  struct soap_plist *pp;
   if (!soap->pblk || soap->pidx >= SOAP_PTRBLK)
-  { register struct soap_pblk *pb = (struct soap_pblk*)SOAP_MALLOC(soap, sizeof(struct soap_pblk));
+  { struct soap_pblk *pb = (struct soap_pblk*)SOAP_MALLOC(soap, sizeof(struct soap_pblk));
     if (!pb)
     { soap->error = SOAP_EOM;
       return 0;
@@ -6782,13 +6782,13 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_array_pointer_lookup(struct soap *soap, const void *p, const struct soap_array *a, int n, int type, struct soap_plist **ppp)
-{ register struct soap_plist *pp;
+{ struct soap_plist *pp;
   *ppp = NULL;
   if (!p || !a->__ptr)
     return 0;
   for (pp = soap->pht[soap_hash_ptr(a->__ptr)]; pp; pp = pp->next)
   { if (pp->type == type && pp->array && pp->array->__ptr == a->__ptr)
-    { register int i;
+    { int i;
       for (i = 0; i < n; i++)
         if (((const int*)&pp->array->__size)[i] != ((const int*)&a->__size)[i])
           break;
@@ -7063,7 +7063,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_array_reference(struct soap *soap, const void *p, const struct soap_array *a, int n, int t)
-{ register int i;
+{ int i;
   struct soap_plist *pp;
   if (!p || !a->__ptr)
     return 1;
@@ -7267,7 +7267,7 @@ soap_attachment(struct soap *soap, const char *tag, int id, const void *p, const
 #ifndef PALM_1
 static void
 soap_init_iht(struct soap *soap)
-{ register int i;
+{ int i;
   for (i = 0; i < SOAP_IDHASH; i++)
     soap->iht[i] = NULL;
 }
@@ -7279,9 +7279,9 @@ soap_init_iht(struct soap *soap)
 #ifndef PALM_1
 static void
 soap_free_iht(struct soap *soap)
-{ register int i;
-  register struct soap_ilist *ip = NULL, *p = NULL;
-  register struct soap_flist *fp = NULL, *fq = NULL;
+{ int i;
+  struct soap_ilist *ip = NULL, *p = NULL;
+  struct soap_flist *fp = NULL, *fq = NULL;
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free ID hashtable\n"));
   for (i = 0; i < SOAP_IDHASH; i++)
   { for (ip = soap->iht[i]; ip; ip = p)
@@ -7305,7 +7305,7 @@ SOAP_FMAC1
 struct soap_ilist *
 SOAP_FMAC2
 soap_lookup(struct soap *soap, const char *id)
-{ register struct soap_ilist *ip = NULL;
+{ struct soap_ilist *ip = NULL;
   for (ip = soap->iht[soap_hash(id)]; ip; ip = ip->next)
     if (!strcmp(ip->id, id))
       return ip;
@@ -7321,8 +7321,8 @@ SOAP_FMAC1
 struct soap_ilist *
 SOAP_FMAC2
 soap_enter(struct soap *soap, const char *id)
-{ register size_t h;
-  register struct soap_ilist *ip;
+{ size_t h;
+  struct soap_ilist *ip;
   ip = (struct soap_ilist*)SOAP_MALLOC(soap, sizeof(struct soap_ilist) + strlen(id));
   if (ip)
   { h = soap_hash(id);
@@ -7341,7 +7341,7 @@ SOAP_FMAC1
 void*
 SOAP_FMAC2
 soap_malloc(struct soap *soap, size_t n)
-{ register char *p;
+{ char *p;
   if (!n)
     return (void*)SOAP_NON_NULL;
   if (!soap)
@@ -7371,7 +7371,7 @@ soap_malloc(struct soap *soap, size_t n)
 #ifdef SOAP_MEM_DEBUG
 static void
 soap_init_mht(struct soap *soap)
-{ register int i;
+{ int i;
   for (i = 0; i < (int)SOAP_PTRHASH; i++)
     soap->mht[i] = NULL;
 }
@@ -7381,8 +7381,8 @@ soap_init_mht(struct soap *soap)
 #ifdef SOAP_MEM_DEBUG
 static void
 soap_free_mht(struct soap *soap)
-{ register int i;
-  register struct soap_mlist *mp, *mq;
+{ int i;
+  struct soap_mlist *mp, *mq;
   for (i = 0; i < (int)SOAP_PTRHASH; i++)
   { for (mp = soap->mht[i]; mp; mp = mq)
     { mq = mp->next;
@@ -7401,10 +7401,10 @@ SOAP_FMAC1
 void*
 SOAP_FMAC2
 soap_track_malloc(struct soap *soap, const char *file, int line, size_t size)
-{ register void *p = malloc(size);
+{ void *p = malloc(size);
   if (soap)
-  { register size_t h = soap_hash_ptr(p);
-    register struct soap_mlist *mp = (struct soap_mlist*)malloc(sizeof(struct soap_mlist));
+  { size_t h = soap_hash_ptr(p);
+    struct soap_mlist *mp = (struct soap_mlist*)malloc(sizeof(struct soap_mlist));
     if (soap->fdebug[SOAP_INDEX_TEST])
     { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "%s(%d): malloc(%lu) = %p\n", file, line, (unsigned long)size, p));
     }
@@ -7425,8 +7425,8 @@ SOAP_FMAC1
 void
 SOAP_FMAC2
 soap_track_free(struct soap *soap, const char *file, int line, void *p)
-{ register size_t h = soap_hash_ptr(p);
-  register struct soap_mlist *mp;
+{ size_t h = soap_hash_ptr(p);
+  struct soap_mlist *mp;
   for (mp = soap->mht[h]; mp; mp = mp->next)
     if (mp->ptr == p)
       break;
@@ -7450,8 +7450,8 @@ soap_track_free(struct soap *soap, const char *file, int line, void *p)
 #ifdef SOAP_MEM_DEBUG
 static void
 soap_track_unlink(struct soap *soap, const void *p)
-{ register size_t h = soap_hash_ptr(p);
-  register struct soap_mlist *mp;
+{ size_t h = soap_hash_ptr(p);
+  struct soap_mlist *mp;
   for (mp = soap->mht[h]; mp; mp = mp->next)
     if (mp->ptr == p)
       break;
@@ -7469,7 +7469,7 @@ soap_dealloc(struct soap *soap, void *p)
 { if (soap_check_state(soap))
     return;
   if (p)
-  { register char **q;
+  { char **q;
     for (q = (char**)&soap->alist; *q; q = *(char***)q)
     {
       if (*(unsigned short*)(char*)(*q - sizeof(unsigned short)) != (unsigned short)SOAP_CANARY)
@@ -7493,7 +7493,7 @@ soap_dealloc(struct soap *soap, void *p)
     soap_delete(soap, p);
   }
   else
-  { register char *q;
+  { char *q;
     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free all soap_malloc() data\n"));
     while (soap->alist)
     { q = (char*)soap->alist;
@@ -7536,14 +7536,14 @@ SOAP_FMAC1
 void
 SOAP_FMAC2
 soap_delete(struct soap *soap, void *p)
-{ register struct soap_clist **cp;
+{ struct soap_clist **cp;
   if (soap_check_state(soap))
     return;
   cp = &soap->clist;
   if (p)
   { while (*cp)
     { if (p == (*cp)->ptr)
-      { register struct soap_clist *q = *cp;
+      { struct soap_clist *q = *cp;
         *cp = q->next;
         if (q->fdelete(q))
         { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not dealloc data %p: deletion callback failed for object type %d\n", q->ptr, q->type));
@@ -7560,7 +7560,7 @@ soap_delete(struct soap *soap, void *p)
   }
   else
   { while (*cp)
-    { register struct soap_clist *q = *cp;
+    { struct soap_clist *q = *cp;
       *cp = q->next;
       if (q->fdelete(q))
       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not dealloc data %p: deletion callback failed for object type %d\n", q->ptr, q->type));
@@ -7582,11 +7582,11 @@ SOAP_FMAC1
 void
 SOAP_FMAC2
 soap_delegate_deletion(struct soap *soap, struct soap *soap_to)
-{ register struct soap_clist *cp;
-  register char **q;
+{ struct soap_clist *cp;
+  char **q;
 #ifdef SOAP_MEM_DEBUG
-  register void *p;
-  register struct soap_mlist **mp, *mq;
+  void *p;
+  struct soap_mlist **mp, *mq;
   size_t h;
 #endif
   for (q = (char**)&soap->alist; *q; q = *(char***)q)
@@ -7637,7 +7637,7 @@ SOAP_FMAC1
 struct soap_clist *
 SOAP_FMAC2
 soap_link(struct soap *soap, void *p, int t, int n, int (*fdelete)(struct soap_clist*))
-{ register struct soap_clist *cp;
+{ struct soap_clist *cp;
   if ((cp = (struct soap_clist*)SOAP_MALLOC(soap, sizeof(struct soap_clist))))
   { cp->next = soap->clist;
     cp->type = t;
@@ -7656,8 +7656,8 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_unlink(struct soap *soap, const void *p)
-{ register char **q;
-  register struct soap_clist **cp;
+{ char **q;
+  struct soap_clist **cp;
   if (soap && p)
   { for (q = (char**)&soap->alist; *q; q = *(char***)q)
     { if (p == (void*)(*q - *(size_t*)(*q + sizeof(void*))))
@@ -7690,7 +7690,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_lookup_type(struct soap *soap, const char *id)
-{ register struct soap_ilist *ip;
+{ struct soap_ilist *ip;
   if (id && *id)
   { ip = soap_lookup(soap, id);
     if (ip)
@@ -7822,7 +7822,7 @@ soap_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st
     return NULL;
   }
   if (fcopy || n < sizeof(void*) || *href != '#')
-  { register struct soap_flist *fp = (struct soap_flist*)SOAP_MALLOC(soap, sizeof(struct soap_flist));
+  { struct soap_flist *fp = (struct soap_flist*)SOAP_MALLOC(soap, sizeof(struct soap_flist));
     if (!fp)
     { soap->error = SOAP_EOM;
       return NULL;
@@ -8168,8 +8168,8 @@ SOAP_FMAC1
 void
 SOAP_FMAC2
 soap_free_temp(struct soap *soap)
-{ register struct soap_attribute *tp, *tq;
-  register struct Namespace *ns;
+{ struct soap_attribute *tp, *tq;
+  struct Namespace *ns;
   soap_free_ns(soap);
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free any remaining temp blocks\n"));
   while (soap->blist)
@@ -8222,7 +8222,7 @@ soap_free_temp(struct soap *soap)
 #ifndef PALM_1
 static void
 soap_free_ns(struct soap *soap)
-{ register struct soap_nlist *np, *nq;
+{ struct soap_nlist *np, *nq;
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Free namespace stack\n"));
   for (np = soap->nlist; np; np = nq)
   { nq = np->next;
@@ -8349,7 +8349,7 @@ soap_copy_context(struct soap *copy, const struct soap *soap)
   if (soap_check_state(soap))
     return NULL;
   if (copy)
-  { register struct soap_plugin *p = NULL;
+  { struct soap_plugin *p = NULL;
     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying context\n"));
 #ifdef __cplusplus
     *copy = *soap;
@@ -8428,7 +8428,7 @@ soap_copy_context(struct soap *copy, const struct soap *soap)
 #endif
     copy->plugins = NULL;
     for (p = soap->plugins; p; p = p->next)
-    { register struct soap_plugin *q = (struct soap_plugin*)SOAP_MALLOC(copy, sizeof(struct soap_plugin));
+    { struct soap_plugin *q = (struct soap_plugin*)SOAP_MALLOC(copy, sizeof(struct soap_plugin));
       if (!q)
         return NULL;
       DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying plugin '%s'\n", p->id));
@@ -8525,10 +8525,10 @@ soap_copy_stream(struct soap *copy, struct soap *soap)
   soap_free_ns(copy);
   soap_set_local_namespaces(copy);
   if (soap->nlist && soap->local_namespaces)
-  { register struct soap_nlist *np = NULL, *nq;
+  { struct soap_nlist *np = NULL, *nq;
     /* copy reversed nlist */
     for (nq = soap->nlist; nq; nq = nq->next)
-    { register struct soap_nlist *nr = np;
+    { struct soap_nlist *nr = np;
       size_t n = sizeof(struct soap_nlist) + strlen(nq->id);
       np = (struct soap_nlist*)SOAP_MALLOC(copy, n);
       if (!np)
@@ -8537,7 +8537,7 @@ soap_copy_stream(struct soap *copy, struct soap *soap)
       np->next = nr;
     }
     while (np)
-    { register const char *s = np->ns;
+    { const char *s = np->ns;
       copy->level = np->level; /* preserve element nesting level */
       if (!s && np->index >= 0)
       { s = soap->local_namespaces[np->index].out;
@@ -8945,7 +8945,7 @@ soap_end(struct soap *soap)
   soap_free_temp(soap);
   soap_dealloc(soap, NULL);
   while (soap->clist)
-  { register struct soap_clist *cp = soap->clist->next;
+  { struct soap_clist *cp = soap->clist->next;
     SOAP_FREE(soap, soap->clist);
     soap->clist = cp;
   }
@@ -8965,9 +8965,9 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_set_namespaces(struct soap *soap, const struct Namespace *p)
-{ register struct Namespace *ns = soap->local_namespaces;
-  register struct soap_nlist *np, *nq, *nr;
-  register unsigned int level = soap->level;
+{ struct Namespace *ns = soap->local_namespaces;
+  struct soap_nlist *np, *nq, *nr;
+  unsigned int level = soap->level;
   soap->namespaces = p;
   soap->local_namespaces = NULL;
   soap_set_local_namespaces(soap);
@@ -8986,7 +8986,7 @@ soap_set_namespaces(struct soap *soap, const struct Namespace *p)
   }
   /* then push on new stack */
   while (np)
-  { register const char *s;
+  { const char *s;
     soap->level = np->level; /* preserve element nesting level */
     s = np->ns;
     if (!s && np->index >= 0 && ns)
@@ -9001,7 +9001,7 @@ soap_set_namespaces(struct soap *soap, const struct Namespace *p)
     SOAP_FREE(soap, nq);
   }
   if (ns)
-  { register int i;
+  { int i;
     for (i = 0; ns[i].id; i++)
     { if (ns[i].out)
       { SOAP_FREE(soap, ns[i].out);
@@ -9022,9 +9022,9 @@ void
 SOAP_FMAC2
 soap_set_local_namespaces(struct soap *soap)
 { if (soap->namespaces && !soap->local_namespaces)
-  { register const struct Namespace *ns1;
-    register struct Namespace *ns2;
-    register size_t n = 1;
+  { const struct Namespace *ns1;
+    struct Namespace *ns2;
+    size_t n = 1;
     for (ns1 = soap->namespaces; ns1->id; ns1++)
       n++;
     n *= sizeof(struct Namespace);
@@ -9053,11 +9053,11 @@ const char *
 SOAP_FMAC2
 soap_tagsearch(const char *big, const char *little)
 { if (little)
-  { register size_t n = strlen(little);
-    register const char *s = big;
+  { size_t n = strlen(little);
+    const char *s = big;
     while (s)
-    { register const char *t = s;
-      register size_t i;
+    { const char *t = s;
+      size_t i;
       for (i = 0; i < n; i++, t++)
       { if (*t != little[i])
           break;
@@ -9083,7 +9083,7 @@ SOAP_FMAC1
 struct soap_nlist *
 SOAP_FMAC2
 soap_lookup_ns(struct soap *soap, const char *tag, size_t n)
-{ register struct soap_nlist *np;
+{ struct soap_nlist *np;
   for (np = soap->nlist; np; np = np->next)
   { if (!strncmp(np->id, tag, n) && !np->id[n])
       return np;
@@ -9097,7 +9097,7 @@ soap_lookup_ns(struct soap *soap, const char *tag, size_t n)
 #ifndef WITH_LEAN
 static struct soap_nlist *
 soap_push_ns(struct soap *soap, const char *id, const char *ns, short utilized)
-{ register struct soap_nlist *np;
+{ struct soap_nlist *np;
   size_t n, k;
   if (soap_tagsearch(soap->c14nexclude, id))
     return NULL;
@@ -9141,7 +9141,7 @@ soap_push_ns(struct soap *soap, const char *id, const char *ns, short utilized)
 #ifndef WITH_LEAN
 static void
 soap_utilize_ns(struct soap *soap, const char *tag)
-{ register struct soap_nlist *np;
+{ struct soap_nlist *np;
   size_t n = 0;
   const char *t = strchr(tag, ':');
   if (t)
@@ -9168,7 +9168,7 @@ SOAP_FMAC2
 soap_element(struct soap *soap, const char *tag, int id, const char *type)
 {
 #ifndef WITH_LEAN
-  register const char *s;
+  const char *s;
 #endif
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Element begin tag='%s' level='%u' id='%d' type='%s'\n", tag, soap->level, id, type ? type : SOAP_STR_EOS));
   soap->level++;
@@ -9186,7 +9186,7 @@ soap_element(struct soap *soap, const char *tag, int id, const char *type)
   { if (soap->evlev >= soap->level)
       soap->evlev = 0;
     if (soap->event == SOAP_SEC_BEGIN && !soap->evlev)
-    { register struct soap_nlist *np;
+    { struct soap_nlist *np;
       /* non-nested wsu:Id found: clear xmlns, re-emit them for exc-c14n */
       for (np = soap->nlist; np; np = np->next)
       { if (np->index == 2)
@@ -9200,7 +9200,7 @@ soap_element(struct soap *soap, const char *tag, int id, const char *type)
   }
 #endif
   if (soap->mode & SOAP_XML_DOM)
-  { register struct soap_dom_element *elt = (struct soap_dom_element*)soap_malloc(soap, sizeof(struct soap_dom_element));
+  { struct soap_dom_element *elt = (struct soap_dom_element*)soap_malloc(soap, sizeof(struct soap_dom_element));
     if (!elt)
       return soap->error;
     elt->soap = soap;
@@ -9311,7 +9311,7 @@ soap_element(struct soap *soap, const char *tag, int id, const char *type)
 #endif
   }
   if (soap->null && soap->position > 0)
-  { register int i;
+  { int i;
     sprintf(soap->tmpbuf, "[%d", soap->positions[0]);
     for (i = 1; i < soap->position; i++)
       sprintf(soap->tmpbuf + strlen(soap->tmpbuf), ",%d", soap->positions[i]);
@@ -9378,7 +9378,7 @@ SOAP_FMAC1
 char*
 SOAP_FMAC2
 soap_strrchr(const char *s, int t)
-{ register char *r = NULL;
+{ char *r = NULL;
   while (*s)
     if (*s++ == t)
       r = (char*)s - 1;
@@ -9394,8 +9394,8 @@ SOAP_FMAC1
 long
 SOAP_FMAC2
 soap_strtol(const char *s, char **t, int b)
-{ register long n = 0;
-  register int c;
+{ long n = 0;
+  int c;
   while (*s > 0 && *s <= 32)
     s++;
   if (b == 10)
@@ -9446,7 +9446,7 @@ unsigned long
 SOAP_FMAC2
 soap_strtoul(const char *s, char **t, int b)
 { unsigned long n = 0;
-  register int c;
+  int c;
   while (*s > 0 && *s <= 32)
     s++;
   if (b == 10)
@@ -9524,7 +9524,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_element_start_end_out(struct soap *soap, const char *tag)
-{ register struct soap_attribute *tp;
+{ struct soap_attribute *tp;
 #ifndef WITH_LEAN
   if (soap->mode & SOAP_XML_CANONICAL)
   { struct soap_nlist *np;
@@ -9544,7 +9544,7 @@ soap_element_start_end_out(struct soap *soap, const char *tag)
 #endif
 #ifdef WITH_DOM
   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
-  { register struct soap_dom_attribute **att;
+  { struct soap_dom_attribute **att;
     att = &soap->dom->atts;
     for (tp = soap->attributes; tp; tp = tp->next)
     { if (tp->visible)
@@ -9658,7 +9658,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_element_ref(struct soap *soap, const char *tag, int id, int href)
-{ register int n = 0;
+{ int n = 0;
   const char *s = "href";
   if (soap->version == 2)
   { s = "SOAP-ENC:ref";
@@ -9798,7 +9798,7 @@ soap_attribute(struct soap *soap, const char *name, const char *value)
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Attribute '%s'='%s'\n", name, value));
 #ifdef WITH_DOM
   if ((soap->mode & SOAP_XML_DOM) && !(soap->mode & SOAP_XML_CANONICAL) && soap->dom)
-  { register struct soap_dom_attribute *a = (struct soap_dom_attribute*)soap_malloc(soap, sizeof(struct soap_dom_attribute));
+  { struct soap_dom_attribute *a = (struct soap_dom_attribute*)soap_malloc(soap, sizeof(struct soap_dom_attribute));
     if (!a)
       return soap->error;
     a->next = soap->dom->atts;
@@ -9868,9 +9868,9 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_element_end_in(struct soap *soap, const char *tag)
-{ register soap_wchar c;
-  register char *s;
-  register int n = 0;
+{ soap_wchar c;
+  char *s;
+  int n = 0;
   if (tag && *tag == '-')
     return SOAP_OK;
   if (soap->error == SOAP_NO_TAG)
@@ -9944,7 +9944,7 @@ SOAP_FMAC1
 const char *
 SOAP_FMAC2
 soap_attr_value(struct soap *soap, const char *name, int flag)
-{ register struct soap_attribute *tp;
+{ struct soap_attribute *tp;
   if (*name == '-')
     return SOAP_STR_EOS;
   for (tp = soap->attributes; tp; tp = tp->next)
@@ -9971,7 +9971,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_set_attr(struct soap *soap, const char *name, const char *value, int flag)
-{ register struct soap_attribute *tp;
+{ struct soap_attribute *tp;
   if (*name == '-')
     return SOAP_OK;
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Set attribute %s='%s'\n", name, value ? value : SOAP_STR_EOS));
@@ -10070,7 +10070,7 @@ SOAP_FMAC1
 void
 SOAP_FMAC2
 soap_clr_attr(struct soap *soap)
-{ register struct soap_attribute *tp;
+{ struct soap_attribute *tp;
 #ifndef WITH_LEAN
   if ((soap->mode & SOAP_XML_CANONICAL))
   { while (soap->attributes)
@@ -10093,9 +10093,9 @@ soap_clr_attr(struct soap *soap)
 #ifndef PALM_2
 static int
 soap_getattrval(struct soap *soap, char *s, size_t n, soap_wchar d)
-{ register size_t i;
+{ size_t i;
   for (i = 0; i < n; i++)
-  { register soap_wchar c = soap_get(soap);
+  { soap_wchar c = soap_get(soap);
     switch (c)
     {
     case SOAP_TT:
@@ -10168,7 +10168,7 @@ int
 SOAP_FMAC2
 soap_append_lab(struct soap *soap, const char *s, size_t n)
 { if (soap->labidx + n >= soap->lablen)
-  { register char *t = soap->labbuf;
+  { char *t = soap->labbuf;
     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Enlarging look-aside buffer to append data, old size=%lu", (unsigned long)soap->lablen));
     if (soap->lablen == 0)
       soap->lablen = SOAP_LABLEN;
@@ -10203,14 +10203,14 @@ SOAP_FMAC2
 soap_peek_element(struct soap *soap)
 {
 #ifdef WITH_DOM
-  register struct soap_dom_attribute **att = NULL;
-  register char *lead = NULL;
-#endif
-  register struct soap_attribute *tp, *tq = NULL;
-  register const char *t;
-  register char *s;
-  register soap_wchar c;
-  register int i;
+  struct soap_dom_attribute **att = NULL;
+  char *lead = NULL;
+#endif
+  struct soap_attribute *tp, *tq = NULL;
+  const char *t;
+  char *s;
+  soap_wchar c;
+  int i;
   if (soap->peeked)
   { if (!*soap->tag)
       return soap->error = SOAP_NO_TAG;
@@ -10297,7 +10297,7 @@ soap_peek_element(struct soap *soap)
   *s = '\0';
 #ifdef WITH_DOM
   if (soap->mode & SOAP_XML_DOM)
-  { register struct soap_dom_element *elt;
+  { struct soap_dom_element *elt;
     elt = (struct soap_dom_element*)soap_malloc(soap, sizeof(struct soap_dom_element));
     if (!elt)
       return soap->error;
@@ -10629,9 +10629,9 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_string_out(struct soap *soap, const char *s, int flag)
-{ register const char *t;
-  register soap_wchar c;
-  register soap_wchar mask = (soap_wchar)0xFFFFFF80UL;
+{ const char *t;
+  soap_wchar c;
+  soap_wchar mask = (soap_wchar)0xFFFFFF80UL;
 #ifdef WITH_DOM
   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
   { soap->dom->data = soap_strdup(soap, s);
@@ -10692,7 +10692,7 @@ soap_string_out(struct soap *soap, const char *s, int flag)
 #ifdef HAVE_MBTOWC
       if (soap->mode & SOAP_C_MBSTRING)
       { wchar_t wc;
-        register int m = mbtowc(&wc, t - 1, MB_CUR_MAX);
+        int m = mbtowc(&wc, t - 1, MB_CUR_MAX);
         if (m > 0 && !((soap_wchar)wc == c && m == 1 && c < 0x80))
         { if (soap_send_raw(soap, s, t - s - 1) || soap_pututf8(soap, wc))
             return soap->error;
@@ -10721,12 +10721,12 @@ SOAP_FMAC1
 char *
 SOAP_FMAC2
 soap_string_in(struct soap *soap, int flag, long minlen, long maxlen)
-{ register char *s;
+{ char *s;
   char *t = NULL;
-  register size_t i;
-  register long l = 0;
-  register int n = 0, f = 0, m = 0;
-  register soap_wchar c;
+  size_t i;
+  long l = 0;
+  int n = 0, f = 0, m = 0;
+  soap_wchar c;
 #if !defined(WITH_LEANER) && defined(HAVE_WCTOMB)
   char buf[MB_LEN_MAX > 8 ? MB_LEN_MAX : 8];
 #else
@@ -10775,7 +10775,7 @@ soap_string_in(struct soap *soap, int flag, long minlen, long maxlen)
   }
 #ifdef WITH_CDATA
   if (!flag)
-  { register int state = 0;
+  { int state = 0;
 #ifdef WITH_FAST
     soap->labidx = 0;			/* use look-aside buffer */
 #else
@@ -10785,14 +10785,14 @@ soap_string_in(struct soap *soap, int flag, long minlen, long maxlen)
     for (;;)
     {
 #ifdef WITH_FAST
-      register size_t k;
+      size_t k;
       if (soap_append_lab(soap, NULL, 0))	/* allocate more space in look-aside buffer if necessary */
         return NULL;
       s = soap->labbuf + soap->labidx;	/* space to populate */
       k = soap->lablen - soap->labidx;	/* number of bytes available */
       soap->labidx = soap->lablen;	/* claim this space */
 #else
-      register size_t k = SOAP_BLKLEN;
+      size_t k = SOAP_BLKLEN;
       if (!(s = (char*)soap_push_block(soap, NULL, k)))
         return NULL;
 #endif
@@ -11022,14 +11022,14 @@ soap_string_in(struct soap *soap, int flag, long minlen, long maxlen)
   for (;;)
   {
 #ifdef WITH_FAST
-    register size_t k;
+    size_t k;
     if (soap_append_lab(soap, NULL, 0))	/* allocate more space in look-aside buffer if necessary */
       return NULL;
     s = soap->labbuf + soap->labidx;	/* space to populate */
     k = soap->lablen - soap->labidx;	/* number of bytes available */
     soap->labidx = soap->lablen;	/* claim this space */
 #else
-    register size_t k = SOAP_BLKLEN;
+    size_t k = SOAP_BLKLEN;
     if (!(s = (char*)soap_push_block(soap, NULL, k)))
       return NULL;
 #endif
@@ -11220,7 +11220,7 @@ SOAP_FMAC2
 soap_wstring_out(struct soap *soap, const wchar_t *s, int flag)
 { const char *t;
   char tmp;
-  register soap_wchar c;
+  soap_wchar c;
 #ifdef WITH_DOM
   if ((soap->mode & SOAP_XML_DOM) && soap->dom)
   { wchar_t *r = (wchar_t*)s;
@@ -11304,9 +11304,9 @@ wchar_t *
 SOAP_FMAC2
 soap_wstring_in(struct soap *soap, int flag, long minlen, long maxlen)
 { wchar_t *s;
-  register int i, n = 0, f = 0;
-  register long l = 0;
-  register soap_wchar c;
+  int i, n = 0, f = 0;
+  long l = 0;
+  soap_wchar c;
   char *t = NULL;
   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Reading wide string content\n"));
   if (soap->peeked)
@@ -12579,7 +12579,7 @@ soap_s2QName(struct soap *soap, const char *s, char **t, long minlen, long maxle
     for (;;)
     { size_t n;
       struct soap_nlist *np;
-      register const char *p;
+      const char *p;
       /* skip blanks */
       while (*s && soap_blank((soap_wchar)*s))
         s++;
@@ -12743,7 +12743,7 @@ soap_s2wchar(struct soap *soap, const char *s, wchar_t **t, long minlen, long ma
     else
     { /* Convert UTF8 to wchar */
       while (*s)
-      { register soap_wchar c, c1, c2, c3, c4;
+      { soap_wchar c, c1, c2, c3, c4;
         c = (unsigned char)*s++;
         if (c < 0x80)
           *r++ = (wchar_t)c;
@@ -12786,8 +12786,8 @@ SOAP_FMAC1
 const char*
 SOAP_FMAC2
 soap_wchar2s(struct soap *soap, const wchar_t *s)
-{ register soap_wchar c;
-  register char *r, *t;
+{ soap_wchar c;
+  char *r, *t;
   const wchar_t *q = s;
   size_t n = 0;
   while ((c = *q++))
@@ -13341,9 +13341,9 @@ SOAP_FMAC1
 const char *
 SOAP_FMAC2
 soap_value(struct soap *soap)
-{ register size_t i;
-  register soap_wchar c = 0;
-  register char *s = soap->tmpbuf;
+{ size_t i;
+  soap_wchar c = 0;
+  char *s = soap->tmpbuf;
   if (!soap->body)
     return SOAP_STR_EOS;
   do c = soap_get(soap);
@@ -13418,8 +13418,8 @@ static size_t
 soap_count_attachments(struct soap *soap)
 {
 #ifndef WITH_LEANER
-  register struct soap_multipart *content;
-  register size_t count = soap->count;
+  struct soap_multipart *content;
+  size_t count = soap->count;
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Calculating the message size with attachments, current count=%lu\n", (unsigned long)count));
   if ((soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))
   { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Calculating the size of DIME attachments\n"));
@@ -13435,10 +13435,10 @@ soap_count_attachments(struct soap *soap)
     }
   }
   if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary)
-  { register size_t n = strlen(soap->mime.boundary);
+  { size_t n = strlen(soap->mime.boundary);
     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Calculating the size of MIME attachments\n"));
     for (content = soap->mime.first; content; content = content->next)
-    { register const char *s;
+    { const char *s;
       /* count \r\n--boundary\r\n */
       count += 6 + n;
       /* count Content-Type: ...\r\n */
@@ -13646,10 +13646,10 @@ soap_putdime(struct soap *soap)
 #ifndef PALM_1
 static char *
 soap_getdimefield(struct soap *soap, size_t n)
-{ register soap_wchar c;
-  register size_t i;
-  register char *s;
-  register char *p = NULL;
+{ soap_wchar c;
+  size_t i;
+  char *s;
+  char *p = NULL;
   if (n)
   { p = (char*)soap_malloc(soap, n + 1);
     if (p)
@@ -13680,9 +13680,9 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_getdimehdr(struct soap *soap)
-{ register soap_wchar c;
-  register char *s;
-  register int i;
+{ soap_wchar c;
+  char *s;
+  int i;
   unsigned char tmp[12];
   size_t optlen, idlen, typelen;
   if (!(soap->mode & SOAP_ENC_DIME))
@@ -13739,7 +13739,7 @@ soap_getdime(struct soap *soap)
   if (soap_move(soap, (long)(((soap->dime.size+3)&(~3))-soap_tell(soap))))
     return soap->error = SOAP_EOF;
   for (;;)
-  { register struct soap_multipart *content;
+  { struct soap_multipart *content;
     if (soap_getdimehdr(soap))
       break;
     if (soap->fdimewriteopen && ((soap->dime.ptr = (char*)soap->fdimewriteopen(soap, soap->dime.id, soap->dime.type, soap->dime.options)) || soap->error))
@@ -13793,9 +13793,9 @@ end:
       if (soap_new_block(soap) == NULL)
         return SOAP_EOM;
       for (;;)
-      { register soap_wchar c;
-        register size_t i;
-        register char *s;
+      { soap_wchar c;
+        size_t i;
+        char *s;
         s = (char*)soap_push_block(soap, NULL, soap->dime.size);
         if (!s)
           return soap->error = SOAP_EOM;
@@ -13870,8 +13870,8 @@ soap_getmimehdr(struct soap *soap)
     return soap->error = SOAP_EOM;
   content = soap->mime.last;
   for (;;)
-  { register char *key = soap->msgbuf;
-    register char *val;
+  { char *key = soap->msgbuf;
+    char *val;
     if (!*key)
       break;
     DBGLOG(TEST,SOAP_MESSAGE(fdebug, "MIME header: %s\n", key));
@@ -13948,11 +13948,11 @@ SOAP_FMAC1
 struct soap_multipart *
 SOAP_FMAC2
 soap_get_mime_attachment(struct soap *soap, void *handle)
-{ register soap_wchar c = 0;
-  register size_t i, m = 0;
-  register char *s, *t = NULL;
-  register struct soap_multipart *content;
-  register short flag = 0;
+{ soap_wchar c = 0;
+  size_t i, m = 0;
+  char *s, *t = NULL;
+  struct soap_multipart *content;
+  short flag = 0;
   if (!(soap->mode & SOAP_ENC_MIME))
     return NULL;
   content = soap->mime.last;
@@ -14066,7 +14066,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_match_cid(struct soap *soap, const char *s, const char *t)
-{ register size_t n;
+{ size_t n;
   if (!s)
     return 1;
   if (!strcmp(s, t))
@@ -14094,10 +14094,10 @@ soap_match_cid(struct soap *soap, const char *s, const char *t)
 static void
 soap_resolve_attachment(struct soap *soap, struct soap_multipart *content)
 { if (content->id)
-  { register struct soap_xlist **xp = &soap->xlist;
+  { struct soap_xlist **xp = &soap->xlist;
     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Resolving attachment data for id=%s\n", content->id));
     while (*xp)
-    { register struct soap_xlist *xq = *xp;
+    { struct soap_xlist *xq = *xp;
       if (!soap_match_cid(soap, xq->id, content->id))
       { DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Found matching attachment %s for content id=%s\n", xq->id, content->id));
         *xp = xq->next;
@@ -14357,8 +14357,8 @@ soap_next_multipart(struct soap_multipart *content)
 static void
 soap_select_mime_boundary(struct soap *soap)
 { while (!soap->mime.boundary || soap_valid_mime_boundary(soap))
-  { register char *s = soap->mime.boundary;
-    register size_t n = 0;
+  { char *s = soap->mime.boundary;
+    size_t n = 0;
     if (s)
       n = strlen(s);
     if (n < 16)
@@ -14387,15 +14387,15 @@ soap_select_mime_boundary(struct soap *soap)
 #ifndef PALM_1
 static int
 soap_valid_mime_boundary(struct soap *soap)
-{ register struct soap_multipart *content;
-  register size_t k;
+{ struct soap_multipart *content;
+  size_t k;
   if (soap->fmimeread)
     return SOAP_OK;
   k = strlen(soap->mime.boundary);
   for (content = soap->mime.first; content; content = content->next)
   { if (content->ptr && content->size >= k)
-    { register const char *p = (const char*)content->ptr;
-      register size_t i;
+    { const char *p = (const char*)content->ptr;
+      size_t i;
       for (i = 0; i < content->size - k; i++, p++)
       { if (!strncmp(p, soap->mime.boundary, k))
           return SOAP_ERR;
@@ -14488,7 +14488,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_begin_recv(struct soap *soap)
-{ register soap_wchar c;
+{ soap_wchar c;
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Initializing for input\n"));
   soap->error = SOAP_OK;
   soap->filterstop = SOAP_OK;
@@ -14839,8 +14839,8 @@ SOAP_FMAC2
 soap_get_http_body(struct soap *soap)
 {
 #ifndef WITH_LEAN
-  register size_t l = 0, n = 0;
-  register char *s;
+  size_t l = 0, n = 0;
+  char *s;
   /* get HTML body of HTTP error content */
   if (!(soap->mode & SOAP_ENC_ZLIB) && (soap->mode & SOAP_IO) != SOAP_IO_CHUNK)
   { n = soap->length;
@@ -14856,19 +14856,19 @@ soap_get_http_body(struct soap *soap)
   for (;;)
   {
 #ifdef WITH_FAST
-    register size_t i, k;
+    size_t i, k;
     if (soap_append_lab(soap, NULL, 0))	/* allocate more space in look-aside buffer if necessary */
       return NULL;
     s = soap->labbuf + soap->labidx;	/* space to populate */
     k = soap->lablen - soap->labidx;	/* number of bytes available */
     soap->labidx = soap->lablen;	/* claim this space */
 #else
-    register size_t i, k = SOAP_BLKLEN;
+    size_t i, k = SOAP_BLKLEN;
     if (!(s = (char*)soap_push_block(soap, NULL, k)))
       return NULL;
 #endif
     for (i = 0; i < k; i++)
-    { register soap_wchar c;
+    { soap_wchar c;
       l++;
       if (n > 0 && l > n)
         goto end;
@@ -14900,7 +14900,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_envelope_begin_in(struct soap *soap)
-{ register struct Namespace *p;
+{ struct Namespace *p;
   soap->part = SOAP_IN_ENVELOPE;
   if (soap_element_begin_in(soap, "SOAP-ENV:Envelope", 0, NULL))
   { if (soap->error == SOAP_TAG_MISMATCH
@@ -15023,8 +15023,8 @@ SOAP_FMAC1
 void
 SOAP_FMAC2
 soap_set_endpoint(struct soap *soap, const char *endpoint)
-{ register const char *s;
-  register size_t i, n;
+{ const char *s;
+  size_t i, n;
   soap->endpoint[0] = '\0';
   soap->host[0] = '\0';
   soap->path[0] = '/';
@@ -15284,9 +15284,9 @@ SOAP_FMAC1
 char*
 SOAP_FMAC2
 soap_s2base64(struct soap *soap, const unsigned char *s, char *t, int n)
-{ register int i;
-  register unsigned long m;
-  register char *p;
+{ int i;
+  unsigned long m;
+  char *p;
   if (!t)
     t = (char*)soap_malloc(soap, (n + 2) / 3 * 4 + 1);
   if (!t)
@@ -15326,10 +15326,10 @@ SOAP_FMAC1
 const char*
 SOAP_FMAC2
 soap_base642s(struct soap *soap, const char *s, char *t, size_t l, int *n)
-{ register size_t i, j;
-  register soap_wchar c;
-  register unsigned long m;
-  register const char *p;
+{ size_t i, j;
+  soap_wchar c;
+  unsigned long m;
+  const char *p;
   if (!s || !*s)
   { if (n)
       *n = 0;
@@ -15408,7 +15408,7 @@ SOAP_FMAC1
 char*
 SOAP_FMAC2
 soap_s2hex(struct soap *soap, const unsigned char *s, char *t, int n)
-{ register char *p;
+{ char *p;
   if (!t)
     t = (char*)soap_malloc(soap, 2 * n + 1);
   if (!t)
@@ -15417,7 +15417,7 @@ soap_s2hex(struct soap *soap, const unsigned char *s, char *t, int n)
   t[0] = '\0';
   if (s)
   { for (; n > 0; n--)
-    { register int m = *s++;
+    { int m = *s++;
       *t++ = (char)((m >> 4) + (m > 159 ? 'a' - 10 : '0'));
       m &= 0x0F;
       *t++ = (char)(m + (m > 9 ? 'a' - 10 : '0'));
@@ -15434,7 +15434,7 @@ SOAP_FMAC1
 const char*
 SOAP_FMAC2
 soap_hex2s(struct soap *soap, const char *s, char *t, size_t l, int *n)
-{ register const char *p;
+{ const char *p;
   if (!s || !*s)
   { if (n)
       *n = 0;
@@ -15450,7 +15450,7 @@ soap_hex2s(struct soap *soap, const char *s, char *t, size_t l, int *n)
     return NULL;
   p = t;
   while (l)
-  { register int d1, d2;
+  { int d1, d2;
     d1 = *s++;
     if (!d1)
       break;
@@ -15476,10 +15476,10 @@ int
 SOAP_FMAC2
 soap_puthttphdr(struct soap *soap, int status, size_t count)
 { if (soap->status != SOAP_GET && soap->status != SOAP_DEL && soap->status != SOAP_CONNECT)
-  { register const char *s = "text/xml; charset=utf-8";
-    register int err = SOAP_OK;
+  { const char *s = "text/xml; charset=utf-8";
+    int err = SOAP_OK;
 #ifndef WITH_LEANER
-    register const char *r = NULL;
+    const char *r = NULL;
 #endif
     if ((status == SOAP_FILE || soap->status == SOAP_PUT || soap->status == SOAP_POST_FILE) && soap->http_content)
       s = soap->http_content;
@@ -15502,7 +15502,7 @@ soap_puthttphdr(struct soap *soap, int status, size_t count)
         s = "application/dime";
     }
     if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary && strlen(soap->mime.boundary) + strlen(soap->mime.start ? soap->mime.start : SOAP_STR_EOS) < sizeof(soap->tmpbuf) - 80)
-    { register const char *t = strchr(s, ';');
+    { const char *t = strchr(s, ';');
       sprintf(soap->tmpbuf, "multipart/related; charset=utf-8; boundary=\"%s\"; type=\"", soap->mime.boundary);
       if (t)
       { strncat(soap->tmpbuf, s, t - s);
@@ -15815,7 +15815,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_send_fault(struct soap *soap)
-{ register int status = soap->error;
+{ int status = soap->error;
   if (status == SOAP_STOP)
     return soap_closesock(soap);
   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Sending back fault struct for error code %d\n", soap->error));
@@ -15876,7 +15876,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_recv_fault(struct soap *soap, int check)
-{ register int status = soap->error;
+{ int status = soap->error;
   DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Check if receiving SOAP Fault\n"));
   if (!check)
   { /* try getfault when no tag or tag mismatched at level 2, otherwise ret */
@@ -15895,7 +15895,7 @@ soap_recv_fault(struct soap *soap, int check)
     soap_set_fault(soap);
   }
   else
-  { register const char *s = *soap_faultcode(soap);
+  { const char *s = *soap_faultcode(soap);
     if (!soap_match_tag(soap, s, "SOAP-ENV:Server") || !soap_match_tag(soap, s, "SOAP-ENV:Receiver"))
       status = SOAP_SVR_FAULT;
     else if (!soap_match_tag(soap, s, "SOAP-ENV:Client") || !soap_match_tag(soap, s, "SOAP-ENV:Sender"))
@@ -15924,7 +15924,7 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_send_empty_response(struct soap *soap, int httpstatuscode)
-{ register soap_mode m = soap->omode;
+{ soap_mode m = soap->omode;
   if (!(m & SOAP_IO_UDP))
   { soap->count = 0;
     if ((m & SOAP_IO) == SOAP_IO_CHUNK)
@@ -15961,7 +15961,7 @@ soap_recv_empty_response(struct soap *soap)
 #ifndef PALM_1
 static const char*
 soap_strerror(struct soap *soap)
-{ register int err = soap->errnum;
+{ int err = soap->errnum;
   if (err)
   {
 #ifndef WIN32
@@ -16024,7 +16024,7 @@ soap_set_error(struct soap *soap, const char *faultcode, const char *faultsubcod
     *soap_faultsubcode(soap) = faultsubcodeQName;
   *soap_faultstring(soap) = faultstring;
   if (faultdetailXML && *faultdetailXML)
-  { register const char **s = soap_faultdetail(soap);
+  { const char **s = soap_faultdetail(soap);
     if (s)
       *s = faultdetailXML;
   }
@@ -16240,8 +16240,8 @@ SOAP_FMAC1
 int
 SOAP_FMAC2
 soap_register_plugin_arg(struct soap *soap, int (*fcreate)(struct soap*, struct soap_plugin*, void*), void *arg)
-{ register struct soap_plugin *p;
-  register int r;
+{ struct soap_plugin *p;
+  int r;
   if (!(p = (struct soap_plugin*)SOAP_MALLOC(soap, sizeof(struct soap_plugin))))
     return soap->error = SOAP_EOM;
   p->id = NULL;
@@ -16265,7 +16265,7 @@ soap_register_plugin_arg(struct soap *soap, int (*fcreate)(struct soap*, struct
 #ifndef PALM_1
 static void *
 fplugin(struct soap *soap, const char *id)
-{ register struct soap_plugin *p;
+{ struct soap_plugin *p;
   for (p = soap->plugins; p; p = p->next)
     if (p->id == id || !strcmp(p->id, id))
       return p->data;
